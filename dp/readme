something to read
https://www.cnblogs.com/kubidemanong/p/11854724.html

动态规划与分治算法的不同点在于：

适用于动态规划求解的问题，在分解之后得到的子问题往往是相互联系的，会出现若干个重叠子问题。
使用动态规划方法会将这些重叠子问题的解保存到表格里，供随后的计算查询使用，从而避免大量的重复计算。
使用缓存（哈希表、集合或数组）保存计算结果，从而避免子问题重复计算的方法，就是「动态规划算法」

能够使用动态规划方法解决的问题必须满足以下三个特征：

最优子结构性质
重叠子问题性质
无后效性

递推--->bottomup

划分阶段：将原问题按顺序（时间顺序、空间顺序或其他顺序）分解为若干个相互联系的「阶段」。划分后的阶段⼀定是有序或可排序的，否则问题⽆法求解。
这里的「阶段」指的是⼦问题的求解过程。每个⼦问题的求解过程都构成⼀个「阶段」，在完成前⼀阶段的求解后才会进⾏后⼀阶段的求解。

定义状态：将和子问题相关的某些变量（位置、数量、体积、空间等等）作为一个「状态」表示出来。状态的选择要满⾜⽆后效性。
一个「状态」对应一个或多个子问题，所谓某个「状态」下的值，指的就是这个「状态」所对应的子问题的解。

状态转移：根据「上一阶段的状态」和「该状态下所能做出的决策」，推导出「下一阶段的状态」。或者说根据相邻两个阶段各个状态之间的关系，确定决策，然后推导出状态间的相互转移方式（即「状态转移方程」）。

初始条件和边界条件：根据问题描述、状态定义和状态转移方程，确定初始条件和边界条件。

最终结果：确定问题的求解目标，然后按照一定顺序求解每一个阶段的问题。最后根据状态转移方程的递推结果，确定最终结果。

    1 split phase
    2 define state
    3 state transfer
    4 inital state
    5 final state

dp[n] vs dp[n+1]
如果是需要达到第n个数的状态 需要n+1.
如果是数组棋盘 只需要 dp[n]



记忆化搜索
记忆化搜索是动态规划的一种实现方式。
在记忆化搜索中，当算法需要计算某个子问题的结果时，它首先检查是否已经计算过该问题。如果已经计算过，则直接返回已经存储的结果；否则，计算该问题，并将结果存储下来以备将来使用


记忆化搜索：「自顶向下」的解决问题，采用自然的递归方式编写过程，在过程中会保存每个子问题的解（通常保存在一个数组或哈希表中）来避免重复计算。

优点：代码清晰易懂，可以有效的处理一些复杂的状态转移方程。有些状态转移方程是非常复杂的，使用记忆化搜索可以将复杂的状态转移方程拆分成多个子问题，通过递归调用来解决。
缺点：可能会因为递归深度过大而导致栈溢出问题。

递推：「自底向上」的解决问题，采用循环的方式编写过程，在过程中通过保存每个子问题的解（通常保存在一个数组或哈希表中）来避免重复计算。

优点：避免了深度过大问题，不存在栈溢出问题。计算顺序比较明确，易于实现。
缺点：无法处理一些复杂的状态转移方程。有些状态转移方程非常复杂，如果使用递推方法来计算，就会导致代码实现变得非常困难

适合使用「记忆化搜索」的场景：

问题的状态转移方程比较复杂，递推关系不是很明确。
问题适合转换为递归形式，并且递归深度不会太深。
适合使用「递推」的场景：

问题的状态转移方程比较简单，递归关系比较明确。
问题不太适合转换为递归形式，或者递归深度过大容易导致栈溢出。

记忆化---> topdown
写出问题的动态规划「状态」和「状态转移方程」。
定义一个缓存（数组或哈希表），用于保存子问题的解。
定义一个递归函数，用于解决问题。在递归函数中，首先检查缓存中是否已经存在需要计算的结果，如果存在则直接返回结果，否则进行计算，并将结果存储到缓存中，再返回结果。
在主函数中，调用递归函数并返回结果。




线性dp 就是可以线性分阶段的动态规划
也就是 每一个阶段都有自己的决策.

单串线性dp
https://github.com/itcharge/LeetCode-Py/blob/main/Contents/10.Dynamic-Programming/03.Linear-DP/01.Linear-DP-01.md#2-%E5%8D%95%E4%B8%B2%E7%BA%BF%E6%80%A7-dp-%E9%97%AE%E9%A2%98
这里解答了 dp[n+1] 初始化 n+1状态
如果我们确确实实需要第n个数的状态 所以需要dp[n+1] 因为数组如果初始化n 只能到 n-1
这种情况就需要手动给dp[0] 一个状态

有一些单串线性 DP 问题在定义状态时需要考虑两个结束位置，只考虑一个结束位置的无法清楚描述问题。这时候我们就需要需要增加一个结束位置维度来定义状态 2维数组的不同用法
也就是state define的妙处, 二维数组可以定义各种state

873题最好地展现了这个点
dp[i][j] 代表了以i,j 为结尾的的最长的fib数列的长度
如果 i +j = k
转移的话dp[j][k] 代表的就是以j k 结尾的最长数列 -->dp[j][k] = max(dp[j][k], dp[i][j] + 1)


双串线性
双串线性 DP 问题：问题的输入为两个数组或两个字符串的线性 DP 问题
定义为dp[i][j]-->在于两个数组之间的关系


矩阵线性
矩阵线性 DP 问题：问题的输入为二维矩阵的线性 DP 问题。状态一般可定义为dp[i][j] 表示从位置0，0 到i，j 相关状态


无串线性
输入不是字符串 也不是数组 就是一个数


expereince
dp关键还是在于对于状态的定义


todo
5 最长回文字符串
494 目标和 背包问题
